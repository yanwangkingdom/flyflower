package com.yw.ffmpegj.libfilter;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.yw.ffmpegj.libavutil.AVClass;
import com.yw.ffmpegj.libavutil.AVFrame;
import com.yw.ffmpegj.libavutil.AVRational;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * JNA Wrapper for library <b>AVFilter</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AVFilterLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avfilter-4";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AVFilterLibrary.JNA_LIBRARY_NAME);
	public static final AVFilterLibrary INSTANCE = (AVFilterLibrary)Native.loadLibrary(AVFilterLibrary.JNA_LIBRARY_NAME, AVFilterLibrary.class);
	public static final int AVFILTER_AUTO_CONVERT_ALL = 0;
	public static final int AVFILTER_AUTO_CONVERT_NONE = -1;
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE = (int)((1 << 16) | (1 << 17));
	public static final int AVFILTER_FLAG_DYNAMIC_INPUTS = (int)(1 << 0);
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (int)(1 << 16);
	public static final int AVFILTER_CMD_FLAG_FAST = (int)2;
	public static final int AVFILTER_FLAG_DYNAMIC_OUTPUTS = (int)(1 << 1);
	public static final int AVFILTER_FLAG_SLICE_THREADS = (int)(1 << 2);
	public static final int AVFILTER_THREAD_SLICE = (int)(1 << 0);
	public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (int)(1 << 17);
	public static final int AVFILTER_CMD_FLAG_ONE = (int)1;
	/*public static class AVFilter extends Structure {
		*//** Filter name. Must be non-NULL and unique among filters. *//*
		public Pointer name;
		*//**
		 * A description of the filter. May be NULL.<br>
		 * * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
		 *//*
		public Pointer description;
		*//**
		 * List of inputs, terminated by a zeroed element.<br>
		 * * NULL if there are no (static) inputs. Instances of filters with<br>
		 * AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in<br>
		 * this list.
		 *//*
		public PointerByReference inputs;
		*//**
		 * List of outputs, terminated by a zeroed element.<br>
		 * * NULL if there are no (static) outputs. Instances of filters with<br>
		 * AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in<br>
		 * this list.
		 *//*
		public PointerByReference outputs;
		*//**
		 * A class for the private data, used to declare filter private AVOptions.<br>
		 * This field is NULL for filters that do not declare any options.<br>
		 * * If this field is non-NULL, the first member of the filter private data<br>
		 * must be a pointer to AVClass, which will be set by libavfilter generic<br>
		 * code to this class.
		 *//*
		public AVFilterLibrary.AVClass priv_class;
		*//** A combination of AVFILTER_FLAG_* *//*
		public int flags;
		*//**
		 * Filter initialization function.<br>
		 * * This callback will be called only once during the filter lifetime, after<br>
		 * all the options have been set, but before links between filters are<br>
		 * established and format negotiation is done.<br>
		 * * Basic filter initialization should be done here. Filters with dynamic<br>
		 * inputs and/or outputs should create those inputs/outputs here based on<br>
		 * provided options. No more changes to this filter's inputs/outputs can be<br>
		 * done after this callback.<br>
		 * * This callback must not assume that the filter links exist or frame<br>
		 * parameters are known.<br>
		 * * @ref AVFilter.uninit "uninit" is guaranteed to be called even if<br>
		 * initialization fails, so this callback does not have to clean up on<br>
		 * failure.<br>
		 * * @return 0 on success, a negative AVERROR on failure
		 *//*
		public AVFilterLibrary.AVFilter.init_callback init;
		*//**
		 * Should be set instead of @ref AVFilter.init "init" by the filters that<br>
		 * want to pass a dictionary of AVOptions to nested contexts that are<br>
		 * allocated during init.<br>
		 * * On return, the options dict should be freed and replaced with one that<br>
		 * contains all the options which could not be processed by this filter (or<br>
		 * with NULL if all the options were processed).<br>
		 * * Otherwise the semantics is the same as for @ref AVFilter.init "init".
		 *//*
		public AVFilterLibrary.AVFilter.init_dict_callback init_dict;
		*//**
		 * Filter uninitialization function.<br>
		 * * Called only once right before the filter is freed. Should deallocate any<br>
		 * memory held by the filter, release any buffer references, etc. It does<br>
		 * not need to deallocate the AVFilterContext.priv memory itself.<br>
		 * * This callback may be called even if @ref AVFilter.init "init" was not<br>
		 * called or failed, so it must be prepared to handle such a situation.
		 *//*
		public AVFilterLibrary.AVFilter.uninit_callback uninit;
		*//**
		 * Query formats supported by the filter on its inputs and outputs.<br>
		 * * This callback is called after the filter is initialized (so the inputs<br>
		 * and outputs are fixed), shortly before the format negotiation. This<br>
		 * callback may be called more than once.<br>
		 * * This callback must set AVFilterLink.out_formats on every input link and<br>
		 * AVFilterLink.in_formats on every output link to a list of pixel/sample<br>
		 * formats that the filter supports on that link. For audio links, this<br>
		 * filter must also set @ref AVFilterLink.in_samplerates "in_samplerates" /<br>
		 * @ref AVFilterLink.out_samplerates "out_samplerates" and<br>
		 * @ref AVFilterLink.in_channel_layouts "in_channel_layouts" /<br>
		 * @ref AVFilterLink.out_channel_layouts "out_channel_layouts" analogously.<br>
		 * * This callback may be NULL for filters with one input, in which case<br>
		 * libavfilter assumes that it supports all input formats and preserves<br>
		 * them on output.<br>
		 * * @return zero on success, a negative value corresponding to an<br>
		 * AVERROR code otherwise
		 *//*
		public AVFilterLibrary.AVFilter.query_formats_callback query_formats;
		*//** < size of private data to allocate for the filter *//*
		public int priv_size;
		*//**
		 * Used by the filter registration system. Must not be touched by any other<br>
		 * code.
		 *//*
		public AVFilterLibrary.AVFilter.ByReference next;
		*//**
		 * Make the filter instance process a command.<br>
		 * * @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only<br>
		 * @param arg    the argument for the command<br>
		 * @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.<br>
		 * @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be<br>
		 *               time consuming then a filter should treat it like an unsupported command<br>
		 * * @returns >=0 on success otherwise an error code.<br>
		 *          AVERROR(ENOSYS) on unsupported commands
		 *//*
		public AVFilterLibrary.AVFilter.process_command_callback process_command;
		*//**
		 * Filter initialization function, alternative to the init()<br>
		 * callback. Args contains the user-supplied parameters, opaque is<br>
		 * used for providing binary data.
		 *//*
		public AVFilterLibrary.AVFilter.init_opaque_callback init_opaque;
		public interface init_callback extends Callback {
			int apply(AVFilterLibrary.AVFilterContext ctx);
		};
		public interface init_dict_callback extends Callback {
			int apply(AVFilterLibrary.AVFilterContext ctx, PointerByReference options);
		};
		public interface uninit_callback extends Callback {
			void apply(AVFilterLibrary.AVFilterContext ctx);
		};
		public interface query_formats_callback extends Callback {
			int apply(AVFilterLibrary.AVFilterContext AVFilterContextPtr1);
		};
		public interface process_command_callback extends Callback {
			int apply(AVFilterLibrary.AVFilterContext AVFilterContextPtr1, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
		};
		public interface init_opaque_callback extends Callback {
			int apply(AVFilterLibrary.AVFilterContext ctx, Pointer opaque);
		};
		public AVFilter() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("name", "description", "inputs", "outputs", "priv_class", "flags", "init", "init_dict", "uninit", "query_formats", "priv_size", "next", "process_command", "init_opaque");
		}
		public static class ByReference extends AVFilter implements Structure.ByReference {
			
		};
		public static class ByValue extends AVFilter implements Structure.ByValue {
			
		};
	};*/
	/*public static class AVFilterContext extends Structure {
		*//** < needed for av_log() and filters common options *//*
		public AVFilterLibrary.AVClass av_class;
		*//** < the AVFilter of which this is an instance *//*
		public AVFilterLibrary.AVFilter.ByReference filter;
		*//** < name of this filter instance *//*
		public Pointer name;
		*//** < array of input pads *//*
		public PointerByReference input_pads;
		*//** < array of pointers to input links *//*
		public AVFilterLibrary.AVFilterLink.ByReference[] inputs;
		*//** < number of input pads *//*
		public int nb_inputs;
		*//** < array of output pads *//*
		public PointerByReference output_pads;
		*//** < array of pointers to output links *//*
		public AVFilterLibrary.AVFilterLink.ByReference[] outputs;
		*//** < number of output pads *//*
		public int nb_outputs;
		*//** < private data for use by the filter *//*
		public Pointer priv;
		*//** < filtergraph this filter belongs to *//*
		public AVFilterLibrary.AVFilterGraph.ByReference graph;
		*//**
		 * Type of multithreading being allowed/used. A combination of<br>
		 * AVFILTER_THREAD_* flags.<br>
		 * * May be set by the caller before initializing the filter to forbid some<br>
		 * or all kinds of multithreading for this filter. The default is allowing<br>
		 * everything.<br>
		 * * When the filter is initialized, this field is combined using bit AND with<br>
		 * AVFilterGraph.thread_type to get the final mask used for determining<br>
		 * allowed threading types. I.e. a threading type needs to be set in both<br>
		 * to be allowed.<br>
		 * * After the filter is initialzed, libavfilter sets this field to the<br>
		 * threading type that is actually used (0 for no multithreading).
		 *//*
		public int thread_type;
		*//** An opaque struct for libavfilter internal use. *//*
		public PointerByReference internal;
		public AVFilterLibrary.AVFilterCommand command_queue;
		*//** < enable expression string *//*
		public Pointer enable_str;
		*//** < parsed expression (AVExpr*) *//*
		public Pointer enable;
		*//** < variable values for the enable expression *//*
		public DoubleByReference var_values;
		*//** < the enabled state from the last expression evaluation *//*
		public int is_disabled;
		public AVFilterContext() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("av_class", "filter", "name", "input_pads", "inputs", "nb_inputs", "output_pads", "outputs", "nb_outputs", "priv", "graph", "thread_type", "internal", "command_queue", "enable_str", "enable", "var_values", "is_disabled");
		}
		public static class ByReference extends AVFilterContext implements Structure.ByReference {
			
		};
		public static class ByValue extends AVFilterContext implements Structure.ByValue {
			
		};
	};*/
	/*public static class AVFilterLink extends Structure {
		*//** < source filter *//*
		public AVFilterLibrary.AVFilterContext.ByReference src;
		*//** < output pad on the source filter *//*
		public PointerByReference srcpad;
		*//** < dest filter *//*
		public AVFilterLibrary.AVFilterContext.ByReference dst;
		*//** < input pad on the dest filter *//*
		public PointerByReference dstpad;
		*//**
		 * @see AVMediaType<br>
		 * < filter media type
		 *//*
		public int type;
		*//**
		 * These parameters apply only to video<br>
		 * < agreed upon image width
		 *//*
		public int w;
		*//** < agreed upon image height *//*
		public int h;
		*//** < agreed upon sample aspect ratio *//*
		public AVRational sample_aspect_ratio;
		*//**
		 * These parameters apply only to audio<br>
		 * < channel layout of current buffer (see libavutil/channel_layout.h)
		 *//*
		public long channel_layout;
		*//** < samples per second *//*
		public int sample_rate;
		*//** < agreed upon media format *//*
		public int format;
		*//**
		 * Define the time base used by the PTS of the frames/samples<br>
		 * which will pass through this link.<br>
		 * During the configuration stage, each filter is supposed to<br>
		 * change only the output timebase, while the timebase of the<br>
		 * input link is assumed to be an unchangeable property.
		 *//*
		public AVRational time_base;
		*//**
		 * Lists of formats and channel layouts supported by the input and output<br>
		 * filters respectively. These lists are used for negotiating the format<br>
		 * to actually be used, which will be loaded into the format and<br>
		 * channel_layout members, above, when chosen.
		 *//*
		public PointerByReference in_formats;
		public PointerByReference out_formats;
		*//**
		 * Lists of channel layouts and sample rates used for automatic<br>
		 * negotiation.
		 *//*
		public PointerByReference in_samplerates;
		public PointerByReference out_samplerates;
		public AVFilterLibrary.AVFilterChannelLayouts in_channel_layouts;
		public AVFilterLibrary.AVFilterChannelLayouts out_channel_layouts;
		*//**
		 * Audio only, the destination filter sets this to a non-zero value to<br>
		 * request that buffers with the given number of samples should be sent to<br>
		 * it. AVFilterPad.needs_fifo must also be set on the corresponding input<br>
		 * pad.<br>
		 * Last buffer before EOF will be padded with silence.
		 *//*
		public int request_samples;
		*//**
		 * stage of the initialization of the link properties (dimensions, etc)<br>
		 * @see init_state_enum
		 *//*
		public int init_state;
		public AVFilterLibrary.AVFilterPool pool;
		*//** Graph the filter belongs to. *//*
		public AVFilterLibrary.AVFilterGraph.ByReference graph;
		*//**
		 * Current timestamp of the link, as defined by the most recent<br>
		 * frame(s), in AV_TIME_BASE units.
		 *//*
		public long current_pts;
		*//** Index in the age array. *//*
		public int age_index;
		*//**
		 * Frame rate of the stream on the link, or 1/0 if unknown;<br>
		 * if left to 0/0, will be automatically be copied from the first input<br>
		 * of the source filter if it exists.<br>
		 * * Sources should set it to the best estimation of the real frame rate.<br>
		 * Filters should update it if necessary depending on their function.<br>
		 * Sinks can use it to set a default output frame rate.<br>
		 * It is similar to the r_frame_rate field in AVStream.
		 *//*
		public AVRational frame_rate;
		*//** Buffer partially filled with samples to achieve a fixed/minimum size. *//*
		public AVFrame partial_buf;
		*//**
		 * Size of the partial buffer to allocate.<br>
		 * Must be between min_samples and max_samples.
		 *//*
		public int partial_buf_size;
		*//**
		 * Minimum number of samples to filter at once. If filter_frame() is<br>
		 * called with fewer samples, it will accumulate them in partial_buf.<br>
		 * This field and the related ones must not be changed after filtering<br>
		 * has started.<br>
		 * If 0, all related fields are ignored.
		 *//*
		public int min_samples;
		*//**
		 * Maximum number of samples to filter at once. If filter_frame() is<br>
		 * called with more samples, it will split them.
		 *//*
		public int max_samples;
		*//**
		 * The buffer reference currently being received across the link by the<br>
		 * destination filter. This is used internally by the filter system to<br>
		 * allow automatic copying of buffers which do not have sufficient<br>
		 * permissions for the destination. This should not be accessed directly<br>
		 * by the filters.
		 *//*
		public AVFilterLibrary.AVFilterBufferRef cur_buf_copy;
		*//**
		 * True if the link is closed.<br>
		 * If set, all attemps of start_frame, filter_frame or request_frame<br>
		 * will fail with AVERROR_EOF, and if necessary the reference will be<br>
		 * destroyed.<br>
		 * If request_frame returns AVERROR_EOF, this flag is set on the<br>
		 * corresponding link.<br>
		 * It can be set also be set by either the source or the destination<br>
		 * filter.
		 *//*
		public int closed;
		*//** Number of channels. *//*
		public int channels;
		*//**
		 * True if a frame is being requested on the link.<br>
		 * Used internally by the framework.
		 *//*
		public int frame_requested;
		*//** Link processing flags. *//*
		public int flags;
		*//** Number of past frames sent through the link. *//*
		public long frame_count;
		public static interface init_state_enum {
			public static final int AVLINK_UNINIT = 0;
			public static final int AVLINK_STARTINIT = 1;
			public static final int AVLINK_INIT = 2;
		};
		public AVFilterLink() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("src", "srcpad", "dst", "dstpad", "type", "w", "h", "sample_aspect_ratio", "channel_layout", "sample_rate", "format", "time_base", "in_formats", "out_formats", "in_samplerates", "out_samplerates", "in_channel_layouts", "out_channel_layouts", "request_samples", "init_state", "pool", "graph", "current_pts", "age_index", "frame_rate", "partial_buf", "partial_buf_size", "min_samples", "max_samples", "cur_buf_copy", "closed", "channels", "frame_requested", "flags", "frame_count");
		}
		public static class ByReference extends AVFilterLink implements Structure.ByReference {
			
		};
		public static class ByValue extends AVFilterLink implements Structure.ByValue {
			
		};
	};*/
	/*public static class AVFilterGraph extends Structure {
		public AVClass av_class;
		public AVFilterContext.ByReference[] filters;
		public int nb_filters;
		*//** < sws options to use for the auto-inserted scale filters *//*
		public Pointer scale_sws_opts;
		*//** < libavresample options to use for the auto-inserted resample filters *//*
		public Pointer resample_lavr_opts;
		*//**
		 * Type of multithreading allowed for filters in this graph. A combination<br>
		 * of AVFILTER_THREAD_* flags.<br>
		 * * May be set by the caller at any point, the setting will apply to all<br>
		 * filters initialized after that. The default is allowing everything.<br>
		 * * When a filter in this graph is initialized, this field is combined using<br>
		 * bit AND with AVFilterContext.thread_type to get the final mask used for<br>
		 * determining allowed threading types. I.e. a threading type needs to be<br>
		 * set in both to be allowed.
		 *//*
		public int thread_type;
		*//**
		 * Maximum number of threads used by filters in this graph. May be set by<br>
		 * the caller before adding any filters to the filtergraph. Zero (the<br>
		 * default) means that the number of threads is determined automatically.
		 *//*
		public int nb_threads;
		*//** Opaque object for libavfilter internal use. *//*
		public PointerByReference internal;
		*//**
		 * Opaque user data. May be set by the caller to an arbitrary value, e.g. to<br>
		 * be used from callbacks like @ref AVFilterGraph.execute.<br>
		 * Libavfilter will not touch this field in any way.
		 *//*
		public Pointer opaque;
		*//**
		 * This callback may be set by the caller immediately after allocating the<br>
		 * graph and before adding any filters to it, to provide a custom<br>
		 * multithreading implementation.<br>
		 * * If set, filters with slice threading capability will call this callback<br>
		 * to execute multiple jobs in parallel.<br>
		 * * If this field is left unset, libavfilter will use its internal<br>
		 * implementation, which may or may not be multithreaded depending on the<br>
		 * platform and build options.
		 *//*
		public AVFilterLibrary.avfilter_execute_func execute;
		*//** < swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions *//*
		public Pointer aresample_swr_opts;
		public AVFilterLink.ByReference[] sink_links;
		public int sink_links_count;
		public int disable_auto_convert;
		public AVFilterGraph() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("av_class", "filters", "nb_filters", "scale_sws_opts", "resample_lavr_opts", "thread_type", "nb_threads", "internal", "opaque", "execute", "aresample_swr_opts", "sink_links", "sink_links_count", "disable_auto_convert");
		}
		public static class ByReference extends AVFilterGraph implements Structure.ByReference {
			
		};
		public static class ByValue extends AVFilterGraph implements Structure.ByValue {
			
		};
	};*/
	public static class AVFilterInOut extends Structure {
		/** unique name for this input/output in the list */
		public Pointer name;
		/** filter context associated to this input/output */
		public AVFilterContext.ByReference filter_ctx;
		/** index of the filt_ctx pad to use for linking */
		public int pad_idx;
		/** next input/input in the list, NULL if this is the last */
		public AVFilterLibrary.AVFilterInOut.ByReference next;
		public AVFilterInOut() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("name", "filter_ctx", "pad_idx", "next");
		}
		public AVFilterInOut(Pointer name, AVFilterContext.ByReference filter_ctx, int pad_idx, AVFilterLibrary.AVFilterInOut.ByReference next) {
			super();
			this.name = name;
			this.filter_ctx = filter_ctx;
			this.pad_idx = pad_idx;
			this.next = next;
		}
		public static class ByReference extends AVFilterInOut implements Structure.ByReference {
			
		};
		public static class ByValue extends AVFilterInOut implements Structure.ByValue {
			
		};
	};
	public interface avfilter_action_func extends Callback {
		int apply(AVFilterContext ctx, Pointer arg, int jobnr, int nb_jobs);
	};
	/*public interface avfilter_execute_func extends Callback {
		int apply(AVFilterContext ctx, AVFilterLibrary.avfilter_action_func func, Pointer arg, IntByReference ret, int nb_jobs);
	};*/
	int avfilter_version();
	Pointer avfilter_configuration();
	Pointer avfilter_license();
	int avfilter_ref_get_channels(AVFilterLibrary.AVFilterBufferRef ref);
	@Deprecated 
	int avfilter_pad_count(Pointer pads);
	int avfilter_pad_count(PointerByReference pads);
	@Deprecated 
	Pointer avfilter_pad_get_name(Pointer pads, int pad_idx);
	Pointer avfilter_pad_get_name(PointerByReference pads, int pad_idx);
	@Deprecated 
	int avfilter_pad_get_type(Pointer pads, int pad_idx);
	int avfilter_pad_get_type(PointerByReference pads, int pad_idx);
	int avfilter_link(Pointer src, int srcpad, Pointer dst, int dstpad);
	//int avfilter_link(AVFilterLibrary.AVFilterContext src, int srcpad, AVFilterLibrary.AVFilterContext dst, int dstpad);
	@Deprecated 
	void avfilter_link_free(PointerByReference link);
	void avfilter_link_free(AVFilterLink.ByReference link[]);
	int avfilter_link_get_channels(AVFilterLink link);
	void avfilter_link_set_closed(AVFilterLink link, int closed);
	int avfilter_config_links(AVFilterContext filter);
	@Deprecated 
	int avfilter_process_command(AVFilterContext filter, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
	int avfilter_process_command(AVFilterContext filter, String cmd, String arg, ByteBuffer res, int res_len, int flags);
	void avfilter_register_all();
	int avfilter_register(AVFilter filter);
	
	//AVFilterLibrary.AVFilter avfilter_get_by_name(Pointer name);
	Pointer avfilter_get_by_name(String name);
	//AVFilter.ByReference avfilter_get_by_name(String name);
	AVFilter avfilter_next(AVFilter prev);
	@Deprecated 
	int avfilter_init_str(AVFilterContext ctx, Pointer args);
	int avfilter_init_str(AVFilterContext ctx, String args);
	int avfilter_init_dict(AVFilterContext ctx, PointerByReference options);
	int avfilter_init_dict(AVFilterContext ctx, AVFilterLibrary.AVDictionary options[]);
	void avfilter_free(AVFilterContext filter);
	int avfilter_insert_filter(AVFilterLink link, AVFilterContext filt, int filt_srcpad_idx, int filt_dstpad_idx);
	AVClass avfilter_get_class();
	//AVFilterLibrary.AVFilterGraph avfilter_graph_alloc();
	Pointer avfilter_graph_alloc();
	@Deprecated 
	AVFilterContext avfilter_graph_alloc_filter(AVFilterGraph graph, AVFilter filter, Pointer name);
	AVFilterContext avfilter_graph_alloc_filter(AVFilterGraph graph, AVFilter filter, String name);
	@Deprecated 
	AVFilterContext avfilter_graph_get_filter(AVFilterGraph graph, Pointer name);
	AVFilterContext avfilter_graph_get_filter(AVFilterGraph graph, ByteBuffer name);
	
	//int avfilter_graph_create_filter(PointerByReference filt_ctx, Pointer filt, String name, Pointer args, Pointer opaque, Pointer graph_ctx);
    int avfilter_graph_create_filter(PointerByReference filt_ctx, Pointer filt, String name, Pointer args, Pointer opaque, Pointer graph_ctx);
	//int avfilter_graph_create_filter(AVFilterLibrary.AVFilterContext.ByReference filt_ctx[], AVFilterLibrary.AVFilter filt, String name, String args, Pointer opaque, AVFilterLibrary.AVFilterGraph graph_ctx);
	//int avfilter_graph_create_filter(AVFilterLibrary.AVFilterContext.ByReference filt_ctx[], AVFilterLibrary.AVFilter filt, Pointer name, Pointer args, Pointer opaque, AVFilterLibrary.AVFilterGraph graph_ctx);
	void avfilter_graph_set_auto_convert(AVFilterGraph graph, int flags);
	int avfilter_graph_config(Pointer graphctx, Pointer log_ctx);

	void avfilter_graph_free(PointerByReference graph);
	//void avfilter_graph_free(AVFilterLibrary.AVFilterGraph.ByReference graph[]);
	Pointer avfilter_inout_alloc();
	@Deprecated 
	void avfilter_inout_free(PointerByReference inout);
	void avfilter_inout_free(AVFilterLibrary.AVFilterInOut.ByReference inout[]);
	@Deprecated 
	int avfilter_graph_parse(AVFilterGraph graph, Pointer filters, AVFilterLibrary.AVFilterInOut inputs, AVFilterLibrary.AVFilterInOut outputs, Pointer log_ctx);
	int avfilter_graph_parse(AVFilterGraph graph, String filters, AVFilterLibrary.AVFilterInOut inputs, AVFilterLibrary.AVFilterInOut outputs, Pointer log_ctx);
	
	//int avfilter_graph_parse_ptr(Pointer graph, Pointer filters, PointerByReference inputs, PointerByReference outputs, Pointer log_ctx);
	int avfilter_graph_parse_ptr(Pointer graph, Pointer filters, PointerByReference inputs, PointerByReference outputs, Pointer log_ctx);
	//int avfilter_graph_parse_ptr(AVFilterGraph graph, String filters, AVFilterLibrary.AVFilterInOut.ByReference inputs[], AVFilterLibrary.AVFilterInOut.ByReference outputs[], Pointer log_ctx);
	//int avfilter_graph_parse_ptr(AVFilterGraph graph, Pointer filters, AVFilterLibrary.AVFilterInOut.ByReference inputs[], AVFilterLibrary.AVFilterInOut.ByReference outputs[], Pointer log_ctx);
	@Deprecated 
	int avfilter_graph_parse2(AVFilterGraph graph, Pointer filters, PointerByReference inputs, PointerByReference outputs);
	int avfilter_graph_parse2(AVFilterGraph graph, String filters, AVFilterLibrary.AVFilterInOut.ByReference inputs[], AVFilterLibrary.AVFilterInOut.ByReference outputs[]);
	int avfilter_graph_parse2(AVFilterGraph graph, Pointer filters, AVFilterLibrary.AVFilterInOut.ByReference inputs[], AVFilterLibrary.AVFilterInOut.ByReference outputs[]);
	@Deprecated 
	int avfilter_graph_send_command(AVFilterGraph graph, Pointer target, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
	int avfilter_graph_send_command(AVFilterGraph graph, String target, String cmd, String arg, ByteBuffer res, int res_len, int flags);
	@Deprecated 
	int avfilter_graph_queue_command(AVFilterGraph graph, Pointer target, Pointer cmd, Pointer arg, int flags, double ts);
	int avfilter_graph_queue_command(AVFilterGraph graph, String target, String cmd, String arg, int flags, double ts);
	@Deprecated 
	Pointer avfilter_graph_dump(AVFilterGraph graph, Pointer options);
	Pointer avfilter_graph_dump(AVFilterGraph graph, String options);
	int avfilter_graph_request_oldest(AVFilterGraph graph);
	/** Pointer to unknown (opaque) type */
	public static class AVFilterInternal extends PointerType {
		public AVFilterInternal(Pointer address) {
			super(address);
		}
		public AVFilterInternal() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVFilterGraphInternal extends PointerType {
		public AVFilterGraphInternal(Pointer address) {
			super(address);
		}
		public AVFilterGraphInternal() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVFilterChannelLayouts extends PointerType {
		public AVFilterChannelLayouts(Pointer address) {
			super(address);
		}
		public AVFilterChannelLayouts() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	
	/** Pointer to unknown (opaque) type */
	
	/** Pointer to unknown (opaque) type */
	public static class AVFilterBufferRef extends PointerType {
		public AVFilterBufferRef(Pointer address) {
			super(address);
		}
		public AVFilterBufferRef() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVFilterFormats extends PointerType {
		public AVFilterFormats(Pointer address) {
			super(address);
		}
		public AVFilterFormats() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVFilterCommand extends PointerType {
		public AVFilterCommand(Pointer address) {
			super(address);
		}
		public AVFilterCommand() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVFilterPool extends PointerType {
		public AVFilterPool(Pointer address) {
			super(address);
		}
		public AVFilterPool() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	
	/** Pointer to unknown (opaque) type */
	public static class AVFilterPad extends PointerType {
		public AVFilterPad(Pointer address) {
			super(address);
		}
		public AVFilterPad() {
			super();
		}
	};
	/** Pointer to unknown (opaque) type */
	public static class AVDictionary extends PointerType {
		public AVDictionary(Pointer address) {
			super(address);
		}
		public AVDictionary() {
			super();
		}
	};
	
	
	
	public int av_buffersrc_add_frame(AVFilterContext ctx, AVFrame frame);
	/**
	 * Add a frame to the buffer source.<br>
	 * * By default, if the frame is reference-counted, this function will take<br>
	 * ownership of the reference(s) and reset the frame. This can be controled<br>
	 * using the flags.<br>
	 * * If this function returns an error, the input frame is not touched.<br>
	 * * @param buffer_src  pointer to a buffer source context<br>
	 * @param frame       a frame, or NULL to mark EOF<br>
	 * @param flags       a combination of AV_BUFFERSRC_FLAG_*<br>
	 * @return            >= 0 in case of success, a negative AVERROR code<br>
	 *                    in case of failure<br>
	 * Original signature : <code>int av_buffersrc_add_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
	 * <i>native declaration : line 143</i>
	 */
	public  int av_buffersrc_add_frame_flags(AVFilterContext buffer_src, AVFrame frame, int flags);
	
	
	/**
	 * 这个方法来自buffersrc.h文件
	 * @param ctx
	 * @param frame
	 * @return
	 */
	public  int av_buffersrc_add_frame(Pointer srcctx, Pointer frame);
	
	public int av_buffersrc_add_frame_flags(Pointer buffer_src,
            Pointer frame, int flags);
	
	/**
	 * 这个方法来自buffersink.h文件
	 * @param ctx
	 * @param frame
	 * @param flags
	 * @return
	 */
	public int av_buffersink_get_frame_flags(Pointer sinkctx, Pointer frame, int flags);
	
	/*public  int graph_check_validity(Pointer graph, Pointer log_ctx);
	
	public  int graph_insert_fifos(Pointer graph, Pointer log_ctx);
	public int graph_config_formats(Pointer graph, Pointer log_ctx);
	public int graph_config_links(Pointer graph, Pointer log_ctx);
	public int ff_avfilter_graph_config_pointers(Pointer graph, Pointer log_ctx);*/
	 
}
