package com.yw.ffmpegj.libsws;


import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
/**
 * JNA Wrapper for library <b>Sws</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface SwsLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "swscale-2";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(SwsLibrary.JNA_LIBRARY_NAME);
	public static final SwsLibrary INSTANCE = (SwsLibrary)Native.loadLibrary(SwsLibrary.JNA_LIBRARY_NAME, SwsLibrary.class);
	public static final int SWS_GAUSS = (int)0x80;
	public static final double SWS_MAX_REDUCE_CUTOFF = (double)0.002;
	public static final int SWS_CS_SMPTE170M = (int)5;
	public static final int SWS_SPLINE = (int)0x400;
	public static final int SWS_PRINT_INFO = (int)0x1000;
	public static final int SWS_BITEXACT = (int)0x80000;
	public static final int SWS_BICUBLIN = (int)0x40;
	public static final int SWS_SINC = (int)0x100;
	public static final int SWS_BICUBIC = (int)4;
	public static final int SWS_CS_ITU601 = (int)5;
	public static final int SWS_AREA = (int)0x20;
	public static final int SWS_CS_ITU709 = (int)1;
	public static final int SWS_DIRECT_BGR = (int)0x8000;
	public static final int SWS_FAST_BILINEAR = (int)1;
	public static final int SWS_CS_SMPTE240M = (int)7;
	public static final int SWS_SRC_V_CHR_DROP_MASK = (int)0x30000;
	public static final int SWS_ACCURATE_RND = (int)0x40000;
	public static final int SWS_CS_DEFAULT = (int)5;
	public static final int SWS_CS_FCC = (int)4;
	public static final int SWS_BILINEAR = (int)2;
	public static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16;
	public static final int SWS_FULL_CHR_H_INP = (int)0x4000;
	public static final int SWS_LANCZOS = (int)0x200;
	public static final int SWS_FULL_CHR_H_INT = (int)0x2000;
	public static final int SWS_POINT = (int)0x10;
	public static final int SWS_ERROR_DIFFUSION = (int)0x800000;
	public static final int SWS_PARAM_DEFAULT = (int)123456;
	public static final int SWS_X = (int)8;
	public static final int SWS_CS_ITU624 = (int)5;
	/**
	 * @defgroup libsws Color conversion and scaling<br>
	 * @{<br>
	 * * Return the LIBSWSCALE_VERSION_INT constant.<br>
	 * Original signature : <code>int swscale_version()</code><br>
	 * <i>native declaration : line 39</i>
	 */
	int swscale_version();
	/**
	 * Return the libswscale build-time configuration.<br>
	 * Original signature : <code>char* swscale_configuration()</code><br>
	 * <i>native declaration : line 44</i>
	 */
	Pointer swscale_configuration();
	/**
	 * Return the libswscale license.<br>
	 * Original signature : <code>char* swscale_license()</code><br>
	 * <i>native declaration : line 49</i>
	 */
	Pointer swscale_license();
	/**
	 * Return a pointer to yuv<->rgb coefficients for the given colorspace<br>
	 * suitable for sws_setColorspaceDetails().<br>
	 * * @param colorspace One of the SWS_CS_* macros. If invalid,<br>
	 * SWS_CS_DEFAULT is used.<br>
	 * Original signature : <code>int* sws_getCoefficients(int)</code><br>
	 * <i>native declaration : line 112</i>
	 */
	IntByReference sws_getCoefficients(int colorspace);
	/**
	 * Return a positive value if pix_fmt is a supported input format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedInput(AVPixelFormat)</code><br>
	 * <i>native declaration : line 135</i>
	 */
	int sws_isSupportedInput(int pix_fmt);
	/**
	 * Return a positive value if pix_fmt is a supported output format, 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int sws_isSupportedOutput(AVPixelFormat)</code><br>
	 * <i>native declaration : line 141</i>
	 */
	int sws_isSupportedOutput(int pix_fmt);
	/**
	 * @param[in]  pix_fmt the pixel format<br>
	 * @return a positive value if an endianness conversion for pix_fmt is<br>
	 * supported, 0 otherwise.<br>
	 * Original signature : <code>int sws_isSupportedEndiannessConversion(AVPixelFormat)</code><br>
	 * <i>native declaration : line 148</i>
	 */
	int sws_isSupportedEndiannessConversion(int pix_fmt);
	/**
	 * Allocate an empty SwsContext. This must be filled and passed to<br>
	 * sws_init_context(). For filling see AVOptions, options.c and<br>
	 * sws_setColorspaceDetails().<br>
	 * Original signature : <code>SwsContext* sws_alloc_context()</code><br>
	 * <i>native declaration : line 155</i>
	 */
	SwsLibrary.SwsContext sws_alloc_context();
	/**
	 * Initialize the swscaler context sws_context.<br>
	 * * @return zero or positive value on success, a negative value on<br>
	 * error<br>
	 * Original signature : <code>int sws_init_context(SwsContext*, SwsFilter*, SwsFilter*)</code><br>
	 * <i>native declaration : line 163</i>
	 */
	int sws_init_context(SwsLibrary.SwsContext sws_context, SwsFilter srcFilter, SwsFilter dstFilter);
	/**
	 * Free the swscaler context swsContext.<br>
	 * If swsContext is NULL, then does nothing.<br>
	 * Original signature : <code>void sws_freeContext(SwsContext*)</code><br>
	 * <i>native declaration : line 169</i>
	 */
	void sws_freeContext(SwsLibrary.SwsContext swsContext);
	/**
	 * Scale the image slice in srcSlice and put the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * * @param c         the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const const uint8_t*[], const int[], int, int, const uint8_t*[], const int[])</code><br>
	 * <i>native declaration : line 220</i><br>
	 * @deprecated use the safer methods {@link #sws_scale(sws.SwsLibrary.SwsContext, byte[][], int[], int, int, byte[][], int[])} and {@link #sws_scale(sws.SwsLibrary.SwsContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int sws_scale(SwsLibrary.SwsContext c, PointerByReference srcSlice, IntByReference srcStride, int srcSliceY, int srcSliceH, PointerByReference dst, IntByReference dstStride);
	/**
	 * Scale the image slice in srcSlice and put the resulting scaled<br>
	 * slice in the image in dst. A slice is a sequence of consecutive<br>
	 * rows in an image.<br>
	 * * Slices have to be provided in sequential order, either in<br>
	 * top-bottom or bottom-top order. If slices are provided in<br>
	 * non-sequential order the behavior of the function is undefined.<br>
	 * * @param c         the scaling context previously created with<br>
	 *                  sws_getContext()<br>
	 * @param srcSlice  the array containing the pointers to the planes of<br>
	 *                  the source slice<br>
	 * @param srcStride the array containing the strides for each plane of<br>
	 *                  the source image<br>
	 * @param srcSliceY the position in the source image of the slice to<br>
	 *                  process, that is the number (counted starting from<br>
	 *                  zero) in the image of the first row of the slice<br>
	 * @param srcSliceH the height of the source slice, that is the number<br>
	 *                  of rows in the slice<br>
	 * @param dst       the array containing the pointers to the planes of<br>
	 *                  the destination image<br>
	 * @param dstStride the array containing the strides for each plane of<br>
	 *                  the destination image<br>
	 * @return          the height of the output slice<br>
	 * Original signature : <code>int sws_scale(SwsContext*, const const uint8_t*[], const int[], int, int, const uint8_t*[], const int[])</code><br>
	 * <i>native declaration : line 220</i>
	 */
	//int sws_scale(SwsLibrary.SwsContext c, byte[] srcSlice[], int srcStride[], int srcSliceY, int srcSliceH, byte[] dst[], int dstStride[]);
	
	int sws_scale(Pointer c, Pointer srcSlice[], int srcStride[], int srcSliceY, int srcSliceH, Pointer dst[], int dstStride[]);
	
	int sws_scale(Pointer c, char srcSlice[], int srcStride[], int srcSliceY, int srcSliceH, char dst[], int dstStride[]);
	
	/**
	 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)<br>
	 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)<br>
	 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param brightness 16.16 fixed point brightness correction<br>
	 * @param contrast 16.16 fixed point contrast correction<br>
	 * @param saturation 16.16 fixed point saturation correction<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : line 234</i><br>
	 * @deprecated use the safer methods {@link #sws_setColorspaceDetails(sws.SwsLibrary.SwsContext, int[], int, int[], int, int, int, int)} and {@link #sws_setColorspaceDetails(sws.SwsLibrary.SwsContext, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int sws_setColorspaceDetails(SwsLibrary.SwsContext c, IntByReference inv_table, int srcRange, IntByReference table, int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)<br>
	 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)<br>
	 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]<br>
	 * @param brightness 16.16 fixed point brightness correction<br>
	 * @param contrast 16.16 fixed point contrast correction<br>
	 * @param saturation 16.16 fixed point saturation correction<br>
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_setColorspaceDetails(SwsContext*, const int[4], int, const int[4], int, int, int, int)</code><br>
	 * <i>native declaration : line 234</i>
	 */
	int sws_setColorspaceDetails(SwsLibrary.SwsContext c, int inv_table[], int srcRange, int table[], int dstRange, int brightness, int contrast, int saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : line 241</i><br>
	 * @deprecated use the safer methods {@link #sws_getColorspaceDetails(sws.SwsLibrary.SwsContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #sws_getColorspaceDetails(sws.SwsLibrary.SwsContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int sws_getColorspaceDetails(SwsLibrary.SwsContext c, PointerByReference inv_table, IntByReference srcRange, PointerByReference table, IntByReference dstRange, IntByReference brightness, IntByReference contrast, IntByReference saturation);
	/**
	 * @return -1 if not supported<br>
	 * Original signature : <code>int sws_getColorspaceDetails(SwsContext*, int**, int*, int**, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : line 241</i>
	 */
	int sws_getColorspaceDetails(SwsLibrary.SwsContext c, PointerByReference inv_table, IntBuffer srcRange, PointerByReference table, IntBuffer dstRange, IntBuffer brightness, IntBuffer contrast, IntBuffer saturation);
	/**
	 * Allocate and return an uninitialized vector with length coefficients.<br>
	 * Original signature : <code>SwsVector* sws_allocVec(int)</code><br>
	 * <i>native declaration : line 248</i>
	 */
	SwsVector sws_allocVec(int length);
	/**
	 * Return a normalized Gaussian curve used to filter stuff<br>
	 * quality = 3 is high quality, lower is lower quality.<br>
	 * Original signature : <code>SwsVector* sws_getGaussianVec(double, double)</code><br>
	 * <i>native declaration : line 254</i>
	 */
	SwsVector sws_getGaussianVec(double variance, double quality);
	/**
	 * Allocate and return a vector with length coefficients, all<br>
	 * with the same value c.<br>
	 * Original signature : <code>SwsVector* sws_getConstVec(double, int)</code><br>
	 * <i>native declaration : line 260</i>
	 */
	SwsVector sws_getConstVec(double c, int length);
	/**
	 * Allocate and return a vector with just one coefficient, with<br>
	 * value 1.0.<br>
	 * Original signature : <code>SwsVector* sws_getIdentityVec()</code><br>
	 * <i>native declaration : line 266</i>
	 */
	SwsVector sws_getIdentityVec();
	/**
	 * Scale all the coefficients of a by the scalar value.<br>
	 * Original signature : <code>void sws_scaleVec(SwsVector*, double)</code><br>
	 * <i>native declaration : line 271</i>
	 */
	void sws_scaleVec(SwsVector a, double scalar);
	/**
	 * Scale all the coefficients of a so that their sum equals height.<br>
	 * Original signature : <code>void sws_normalizeVec(SwsVector*, double)</code><br>
	 * <i>native declaration : line 276</i>
	 */
	void sws_normalizeVec(SwsVector a, double height);
	/**
	 * Original signature : <code>void sws_convVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : line 277</i>
	 */
	void sws_convVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_addVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : line 278</i>
	 */
	void sws_addVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_subVec(SwsVector*, SwsVector*)</code><br>
	 * <i>native declaration : line 279</i>
	 */
	void sws_subVec(SwsVector a, SwsVector b);
	/**
	 * Original signature : <code>void sws_shiftVec(SwsVector*, int)</code><br>
	 * <i>native declaration : line 280</i>
	 */
	void sws_shiftVec(SwsVector a, int shift);
	/**
	 * Allocate and return a clone of the vector a, that is a vector<br>
	 * with the same coefficients as a.<br>
	 * Original signature : <code>SwsVector* sws_cloneVec(SwsVector*)</code><br>
	 * <i>native declaration : line 286</i>
	 */
	SwsVector sws_cloneVec(SwsVector a);
	/**
	 * Print with av_log() a textual representation of the vector a<br>
	 * if log_level <= av_log_level.<br>
	 * Original signature : <code>void sws_printVec2(SwsVector*, AVClass*, int)</code><br>
	 * <i>native declaration : line 292</i>
	 */
	void sws_printVec2(SwsVector a, SwsLibrary.AVClass log_ctx, int log_level);
	/**
	 * Original signature : <code>void sws_freeVec(SwsVector*)</code><br>
	 * <i>native declaration : line 294</i>
	 */
	void sws_freeVec(SwsVector a);
	/**
	 * Original signature : <code>SwsFilter* sws_getDefaultFilter(float, float, float, float, float, float, int)</code><br>
	 * <i>native declaration : line 296</i>
	 */
	SwsFilter sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);
	/**
	 * Original signature : <code>void sws_freeFilter(SwsFilter*)</code><br>
	 * <i>native declaration : line 300</i>
	 */
	void sws_freeFilter(SwsFilter filter);
	
	
	Pointer sws_getCachedContext(Pointer context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, Pointer srcFilter, Pointer dstFilter, DoubleByReference param);
	
	/**
	 * Check if context can be reused, otherwise reallocate a new one.<br>
	 * * If context is NULL, just calls sws_getContext() to get a new<br>
	 * context. Otherwise, checks if the parameters are the ones already<br>
	 * saved in context. If that is the case, returns the current<br>
	 * context. Otherwise, frees context and gets a new context with<br>
	 * the new parameters.<br>
	 * * Be warned that srcFilter and dstFilter are not checked, they<br>
	 * are assumed to remain the same.<br>
	 * Original signature : <code>SwsContext* sws_getCachedContext(SwsContext*, int, int, AVPixelFormat, int, int, AVPixelFormat, int, SwsFilter*, SwsFilter*, const double*)</code><br>
	 * <i>native declaration : line 314</i>
	 */
	//SwsLibrary.SwsContext sws_getCachedContext(SwsLibrary.SwsContext context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, SwsFilter srcFilter, SwsFilter dstFilter, double param[]);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.<br>
	 * * The output frame will have the same packed format as the palette.<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : line 330</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked32(byte[], java.nio.ByteBuffer, int, byte[])} and {@link #sws_convertPalette8ToPacked32(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void sws_convertPalette8ToPacked32(Pointer src, Pointer dst, int num_pixels, Pointer palette);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.<br>
	 * * The output frame will have the same packed format as the palette.<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked32(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : line 330</i>
	 */
	void sws_convertPalette8ToPacked32(byte src[], ByteBuffer dst, int num_pixels, byte palette[]);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : line 342</i><br>
	 * @deprecated use the safer methods {@link #sws_convertPalette8ToPacked24(byte[], java.nio.ByteBuffer, int, byte[])} and {@link #sws_convertPalette8ToPacked24(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void sws_convertPalette8ToPacked24(Pointer src, Pointer dst, int num_pixels, Pointer palette);
	/**
	 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.<br>
	 * * With the palette format "ABCD", the destination frame ends up with the format "ABC".<br>
	 * * @param src        source frame buffer<br>
	 * @param dst        destination frame buffer<br>
	 * @param num_pixels number of pixels to convert<br>
	 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src<br>
	 * Original signature : <code>void sws_convertPalette8ToPacked24(const uint8_t*, uint8_t*, int, const uint8_t*)</code><br>
	 * <i>native declaration : line 342</i>
	 */
	void sws_convertPalette8ToPacked24(byte src[], ByteBuffer dst, int num_pixels, byte palette[]);
	/**
	 * Get the AVClass for swsContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* sws_get_class()</code><br>
	 * <i>native declaration : line 350</i>
	 */
	SwsLibrary.AVClass sws_get_class();
	public static class AVClass extends PointerType {
		public AVClass(Pointer address) {
			super(address);
		}
		public AVClass() {
			super();
		}
	};
	public static class SwsContext extends PointerType {
		public SwsContext(Pointer address) {
			super(address);
		}
		public SwsContext() {
			super();
		}
	};
}

